diff --git python_orocos_kdl/PyKDL/PyKDL.sip python_orocos_kdl/PyKDL/PyKDL.sip
index 4535608..79790a1 100644
--- python_orocos_kdl/PyKDL/PyKDL.sip
+++ python_orocos_kdl/PyKDL/PyKDL.sip
@@ -28,3 +28,5 @@
 %Include frames.sip
 %Include kinfam.sip
 %Include framevel.sip
+
+%Include dynamics.sip
diff --git python_orocos_kdl/PyKDL/dynamics.sip python_orocos_kdl/PyKDL/dynamics.sip
new file mode 100644
index 0000000..a447149
--- /dev/null
+++ python_orocos_kdl/PyKDL/dynamics.sip
@@ -0,0 +1,54 @@
+%Include std_string.sip
+
+class JntSpaceInertiaMatrix {
+%TypeHeaderCode
+#include <kdl/jntspaceinertiamatrix.hpp>
+using namespace KDL;
+%End
+public:
+    JntSpaceInertiaMatrix();
+    JntSpaceInertiaMatrix(int size);
+    JntSpaceInertiaMatrix(const JntSpaceInertiaMatrix& arg);
+    void resize(unsigned int newSize);
+    unsigned int rows()const;
+    unsigned int columns()const;
+    //JntSpaceInertiaMatrix& operator = ( const JntSpaceInertiaMatrix& arg);
+    double __getitem__(SIP_PYTUPLE);
+%MethodCode
+    int i,j;
+    PyArg_ParseTuple(a0,"ii",&i,&j);
+    if (i < 0 || j < 0 || i > sipCpp->rows() || j >= sipCpp->columns()) {
+        PyErr_SetString(PyExc_IndexError, "Inertia index out of range");
+        return NULL;
+    }
+    sipRes=(*sipCpp)(i,j);
+%End
+    //double operator()(unsigned int i,unsigned int j)const;
+    //double& operator()(unsigned int i,unsigned int j);
+    //bool operator==(const JntSpaceInertiaMatrix& src1,const JntSpaceInertiaMatrix& src2);
+    //bool operator!=(const JntSpaceInertiaMatrix& src1,const JntSpaceInertiaMatrix& src2);
+
+};
+void Add(const JntSpaceInertiaMatrix& src1,const JntSpaceInertiaMatrix& src2,JntSpaceInertiaMatrix& dest);
+void Subtract(const JntSpaceInertiaMatrix& src1,const JntSpaceInertiaMatrix& src2,JntSpaceInertiaMatrix& dest);
+void Multiply(const JntSpaceInertiaMatrix& src,const double& factor,JntSpaceInertiaMatrix& dest);
+void Divide(const JntSpaceInertiaMatrix& src,const double& factor,JntSpaceInertiaMatrix& dest);
+void Multiply(const JntSpaceInertiaMatrix& src, const JntArray& vec, JntArray& dest);
+void SetToZero(JntSpaceInertiaMatrix& matrix);
+bool Equal(const JntSpaceInertiaMatrix& src1,const JntSpaceInertiaMatrix& src2,double eps=epsilon);
+bool operator==(const JntSpaceInertiaMatrix& src1,const JntSpaceInertiaMatrix& src2);
+
+class ChainDynParam {
+    
+%TypeHeaderCode
+#include <kdl/chaindynparam.hpp>
+using namespace KDL;
+%End
+
+public:
+    ChainDynParam(const Chain& chain, Vector _grav);
+
+    int JntToCoriolis(const JntArray &q, const JntArray &q_dot, JntArray &coriolis);
+	int JntToMass(const JntArray &q, JntSpaceInertiaMatrix& H);
+	int JntToGravity(const JntArray &q,JntArray &gravity);
+};
diff --git python_orocos_kdl/PyKDL/kinfam.sip python_orocos_kdl/PyKDL/kinfam.sip
index c6b2570..6bc9586 100644
--- python_orocos_kdl/PyKDL/kinfam.sip
+++ python_orocos_kdl/PyKDL/kinfam.sip
@@ -19,7 +19,6 @@
 //License along with this library; if not, write to the Free Software
 //Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 
-
 class Joint{
 
 %TypeHeaderCode
@@ -148,6 +147,24 @@ public:
 
 };
 
+class Tree {
+%TypeHeaderCode
+#include <kdl/tree.hpp>
+using namespace KDL;
+%End
+public:
+    Tree(const std::string& root_name="root");
+    bool addSegment(const Segment& segment, const std::string& hook_name);
+    unsigned int getNrOfJoints()const;
+    unsigned int getNrOfSegments()const;
+    Chain* getChain(const std::string& chain_root, const std::string& chain_tip)const;
+%MethodCode
+    Chain* chain = new Chain();
+    sipCpp->getChain(*a0, *a1, *chain);
+    sipRes = chain;
+%End
+};
+
 class JntArray{
 
 %TypeHeaderCode
@@ -361,6 +378,20 @@ public:
     virtual int CartToJnt(const JntArray& q_init , const Frame& p_in ,JntArray& q_out);
 };
 
+class ChainIkSolverPos_NR_JL : ChainIkSolverPos
+{
+%TypeHeaderCode
+#include <kdl/chainiksolverpos_nr_jl.hpp>
+using namespace KDL;
+%End
+public:
+    ChainIkSolverPos_NR_JL(const Chain& chain,const JntArray &q_min,const JntArray &q_max, 
+                        ChainFkSolverPos& fksolver,ChainIkSolverVel& iksolver,
+                        unsigned int maxiter=100,double eps=epsilon);
+    
+    virtual int CartToJnt(const JntArray& q_init , const Frame& p_in ,JntArray& q_out);
+};
+
 class ChainIkSolverVel_pinv : ChainIkSolverVel
 {
 %TypeHeaderCode
diff --git python_orocos_kdl/PyKDL/std_string.sip python_orocos_kdl/PyKDL/std_string.sip
index d66d822..3d0cc14 100644
--- python_orocos_kdl/PyKDL/std_string.sip
+++ python_orocos_kdl/PyKDL/std_string.sip
@@ -24,11 +24,11 @@
 %ConvertFromTypeCode
     // convert an std::string to a Python (unicode) string
     PyObject* newstring;
-    //newstring = PyUnicode_DecodeUTF8(sipCpp->c_str(), sipCpp->length(), NULL);
-    //if(newstring == NULL) {
-        //PyErr_Clear();
+    newstring = PyUnicode_DecodeUTF8(sipCpp->c_str(), sipCpp->length(), NULL);
+    if(newstring == NULL) {
+        PyErr_Clear();
         newstring = PyString_FromString(sipCpp->c_str());
-    //}
+    }
     return newstring;
 %End
 
@@ -43,14 +43,12 @@
         *sipCppPtr = new std::string;
          return 1;
      }
-     /*
      if (PyUnicode_Check(sipPy)) {
         PyObject* s = PyUnicode_AsEncodedString(sipPy, "UTF-8", "");
         *sipCppPtr = new std::string(PyString_AS_STRING(s));
         Py_DECREF(s);
         return 1;
      }
-     */
      if (PyString_Check(sipPy)) {
         *sipCppPtr = new std::string(PyString_AS_STRING(sipPy));
         return 1;
